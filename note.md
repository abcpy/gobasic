值传递？ 引用传递

Go 只有值传递一种方式

值传递 和 指针

通过指针实现引用传递

数组是值类型

[10]int 和 [20]int 是不同类型

调用 func f(arr [10]int) 会拷贝 数组

在go语言中一般不直接使用数组

###Slice:
Slice 本身没有数据， 是对底层array的一个view

Slice可以向后扩展， 不可以向前扩展

s[i] 不可以超越len(s), 向后扩展不可以超越底层数组cap(s)

添加元素是如果超越cap, 系统会重新分配更大的底层数组

由于值传递的关系，必须接收append的返回值

rune: 相当于go的char

###面向对象：

go语言仅支持封装，不支持继承和多态

Struct

nil指针也可以调用方法

###值接收者 VS 指针接收者:

(A) 要改变内容必须使用指针接收者

(B) 结构体大也考虑使用指针接收者

(C) 一致性: 如有指针接收者， 最好都是指针接收者

###封装：

(A): 名字一般使用CamelCase

(B): 首字母大写: public

(C): 首字母小写: private

###包:

扩展已有类型:

1. 定义别名
2. 使用组合

###GO 语言的依赖管理
go mod
1. 初始化: go mode init
2. 增加依赖: go get
3. 更新依赖 go get [@v...], go mod tidy
4. 将项目迁移到 go mod: go mod init, go build ./...

### 接口
1. duck typing
2. 接口由使用者定义
3. 表示任何类型 interface{}

### 函数
1. 函数是一等公民: 参数， 变量， 返回值都可以是函数
2. 高阶函数
3. 函数 -> 闭包

### 资源管理与出错处理
1. defer调用: 确保调用在函数结束时发生
2. panic: 停止当前函数执行
3. recover: 仅在defer调用中使用

### 测试
表格测试

###并发编程 goroutine
1. 协程 Coroutine: 轻量级 "线程"
2. 非抢占式多任务处理，由协程主动交出控制权
3. 编译器/解释器/虚拟机层面的多任务
4. 多个协程可能在一个或多个线程上运行
5. 






